<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS LUT Generator f√ºr Farbfilterung</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }
        .container {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        h1 {
            color: #e0e0e0;
            text-align: center;
        }
        .upload-section, .color-section, .preview-section, .generate-section {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #252525;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ccc;
        }
        button {
            background-color: #e65c00;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px 5px 5px 0;
        }
        button:hover {
            background-color: #ff6600;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .button-icon {
            background-color: #444;
            color: white;
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-left: 5px;
        }
        .button-icon:hover {
            background-color: #555;
        }
        .button-icon:disabled {
            background-color: #333;
            cursor: not-allowed;
        }
        .screenshot-button {
            background-color: #0d7377;
            font-size: 18px;
            padding: 15px 20px;
        }
        .screenshot-button:hover {
            background-color: #14a085;
        }
        .zoom-button {
            background-color: #6a4c93;
            font-size: 14px;
            padding: 8px 12px;
            margin: 2px;
        }
        .zoom-button:hover {
            background-color: #8b5fbf;
        }
        .color-picker {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        .preview-container {
            display: flex;
            gap: 20px;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .preview-item {
            flex: 1;
            min-width: 400px;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            border: 1px solid #444;
            background-color: #111;
            overflow: auto;
            cursor: grab;
        }
        .canvas-container:active {
            cursor: grabbing;
        }
        .canvas-container.eyedropper-active {
            cursor: crosshair;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
        }
        .zoom-info {
            color: #ccc;
            font-size: 14px;
            margin-left: 10px;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container input {
            width: 100%;
            background-color: #333;
        }
        .range-display {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: #aaa;
        }
        .color-display {
            width: 50px;
            height: 50px;
            border: 1px solid #444;
        }
        input[type="color"] {
            background-color: #333;
            border: none;
            height: 30px;
        }
        input[type="file"] {
            color: #ccc;
            background-color: #333;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        .eyedropper-active {
            cursor: crosshair !important;
        }
        .color-container {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background-color: #2a2a2a;
        }
        .color-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .color-controls {
            display: flex;
            align-items: center;
        }
        h3 {
            color: #ddd;
            margin-top: 0;
        }
        .upload-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .status-success {
            background-color: #1b4332;
            color: #d1e7dd;
            border: 1px solid #52c41a;
        }
        .status-error {
            background-color: #4a1e1e;
            color: #f8d7da;
            border: 1px solid #dc3545;
        }
        .status-info {
            background-color: #1e2a4a;
            color: #cce7ff;
            border: 1px solid #0ea5e9;
        }
        .auto-update-toggle {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .auto-update-toggle input[type="checkbox"] {
            transform: scale(1.2);
        }
        .recording-indicator {
            display: none;
            color: #ff4444;
            font-weight: bold;
            margin-left: 10px;
        }
        .recording-indicator.active {
            display: inline;
        }
        .crop-info {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 14px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OBS LUT Generator f√ºr Farbfilterung</h1>

        <div class="upload-section">
            <h3>Bildquelle w√§hlen</h3>
            <div class="upload-options">
                <input type="file" id="imageUpload" accept="image/*" style="flex: 1;">
                <button id="screenshotBtn" class="screenshot-button">üì∑ Screenshot erstellen</button>
                <button id="startScreenShareBtn" class="screenshot-button">üñ•Ô∏è Screen teilen</button>
                <span class="recording-indicator" id="recordingIndicator">‚óè REC</span>
            </div>
            <div id="statusMessage" class="status-message"></div>
        </div>

        <div class="color-section">
            <h3>Farbeinstellungen</h3>
            <div class="auto-update-toggle">
                <label for="autoUpdateCheckbox">
                    <input type="checkbox" id="autoUpdateCheckbox" checked>
                    Automatische Vorschau-Aktualisierung
                </label>
            </div>
            <div id="colorsContainer">
                <!-- Farben werden hier dynamisch hinzugef√ºgt -->
            </div>
            
            <button id="addColorBtn">Farbe hinzuf√ºgen</button>
            
            <div class="slider-container">
                <label for="brightnessSlider">Helligkeitstoleranz:</label>
                <input type="range" id="brightnessSlider" min="0" max="100" value="30">
                <div class="range-display">
                    <span>Gering</span>
                    <span>Hoch</span>
                </div>
            </div>
            
            <button id="previewBtn">Vorschau manuell aktualisieren</button>
        </div>

        <div class="preview-section">
            <h3>Vorschau mit Zoom & Navigation</h3>
            
            <div class="zoom-controls">
                <button id="zoomInBtn" class="zoom-button">üîç+ Hineinzoomen</button>
                <button id="zoomOutBtn" class="zoom-button">üîç- Herauszoomen</button>
                <button id="zoomResetBtn" class="zoom-button">‚Üª Zur√ºcksetzen</button>
                <button id="zoomFitBtn" class="zoom-button">‚äû Anpassen</button>
                <span class="zoom-info" id="zoomInfo">Zoom: 100%</span>
            </div>
            
            <div class="crop-info">
                üí° <strong>Zoom-Tipps:</strong> Zoomen Sie hinein um spezifische UI-Bereiche zu bearbeiten. Ziehen Sie mit der Maus zum Navigieren. Pipette funktioniert auch im gezoomten Modus.
            </div>
            
            <div class="preview-container">
                <div class="preview-item">
                    <label>Original:</label>
                    <div class="canvas-container" id="originalContainer">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
                <div class="preview-item">
                    <label>Gefiltert (nur ausgew√§hlte Farben):</label>
                    <div class="canvas-container" id="filteredContainer">
                        <canvas id="filteredCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="generate-section">
            <h3>LUT generieren</h3>
            <p>Wenn die Vorschau Ihren Erwartungen entspricht, k√∂nnen Sie die LUT-Datei generieren und herunterladen.</p>
            <button id="generateBtn">LUT-Datei generieren (.cube)</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const imageUpload = document.getElementById('imageUpload');
            const screenshotBtn = document.getElementById('screenshotBtn');
            const startScreenShareBtn = document.getElementById('startScreenShareBtn');
            const colorsContainer = document.getElementById('colorsContainer');
            const addColorBtn = document.getElementById('addColorBtn');
            const brightnessSlider = document.getElementById('brightnessSlider');
            const previewBtn = document.getElementById('previewBtn');
            const generateBtn = document.getElementById('generateBtn');
            const originalCanvas = document.getElementById('originalCanvas');
            const filteredCanvas = document.getElementById('filteredCanvas');
            const originalContainer = document.getElementById('originalContainer');
            const filteredContainer = document.getElementById('filteredContainer');
            const autoUpdateCheckbox = document.getElementById('autoUpdateCheckbox');
            const statusMessage = document.getElementById('statusMessage');
            const recordingIndicator = document.getElementById('recordingIndicator');
            
            // Zoom controls
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomResetBtn = document.getElementById('zoomResetBtn');
            const zoomFitBtn = document.getElementById('zoomFitBtn');
            const zoomInfo = document.getElementById('zoomInfo');
            
            let originalImage = null;
            let colorCounter = 0;
            let eyedropperActive = false;
            let targetColorPicker = null;
            let screenStream = null;
            let isScreenSharing = false;
            
            // Zoom and pan variables
            let zoomLevel = 1;
            let isPanning = false;
            let panStartX = 0;
            let panStartY = 0;
            let containerStartScrollX = 0;
            let containerStartScrollY = 0;
            
            // Erste Farbe hinzuf√ºgen
            addColorControl();
            
            // Zoom functionality
            function updateZoom() {
                const canvasWidth = originalCanvas.width * zoomLevel;
                const canvasHeight = originalCanvas.height * zoomLevel;
                
                originalCanvas.style.width = canvasWidth + 'px';
                originalCanvas.style.height = canvasHeight + 'px';
                filteredCanvas.style.width = canvasWidth + 'px';
                filteredCanvas.style.height = canvasHeight + 'px';
                
                zoomInfo.textContent = `Zoom: ${Math.round(zoomLevel * 100)}%`;
            }
            
            zoomInBtn.addEventListener('click', function() {
                zoomLevel = Math.min(zoomLevel * 1.5, 10);
                updateZoom();
            });
            
            zoomOutBtn.addEventListener('click', function() {
                zoomLevel = Math.max(zoomLevel / 1.5, 0.1);
                updateZoom();
            });
            
            zoomResetBtn.addEventListener('click', function() {
                zoomLevel = 1;
                updateZoom();
                originalContainer.scrollLeft = 0;
                originalContainer.scrollTop = 0;
                filteredContainer.scrollLeft = 0;
                filteredContainer.scrollTop = 0;
            });
            
            zoomFitBtn.addEventListener('click', function() {
                if (!originalImage) return;
                
                const containerWidth = originalContainer.clientWidth;
                const containerHeight = originalContainer.clientHeight;
                const imageWidth = originalCanvas.width;
                const imageHeight = originalCanvas.height;
                
                const scaleX = containerWidth / imageWidth;
                const scaleY = containerHeight / imageHeight;
                zoomLevel = Math.min(scaleX, scaleY, 1);
                
                updateZoom();
                originalContainer.scrollLeft = 0;
                originalContainer.scrollTop = 0;
                filteredContainer.scrollLeft = 0;
                filteredContainer.scrollTop = 0;
            });
            
            // Mouse wheel zoom
            function handleWheel(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    zoomLevel = Math.max(0.1, Math.min(10, zoomLevel * delta));
                    updateZoom();
                }
            }
            
            originalContainer.addEventListener('wheel', handleWheel);
            filteredContainer.addEventListener('wheel', handleWheel);
            
            // Pan functionality
            function startPan(e, container) {
                if (eyedropperActive) return;
                
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                containerStartScrollX = container.scrollLeft;
                containerStartScrollY = container.scrollTop;
                container.style.cursor = 'grabbing';
            }
            
            function doPan(e, container) {
                if (!isPanning || eyedropperActive) return;
                
                e.preventDefault();
                const deltaX = e.clientX - panStartX;
                const deltaY = e.clientY - panStartY;
                
                container.scrollLeft = containerStartScrollX - deltaX;
                container.scrollTop = containerStartScrollY - deltaY;
            }
            
            function endPan(container) {
                isPanning = false;
                container.style.cursor = eyedropperActive ? 'crosshair' : 'grab';
            }
            
            // Pan event listeners for both containers
            [originalContainer, filteredContainer].forEach(container => {
                container.addEventListener('mousedown', (e) => startPan(e, container));
                container.addEventListener('mousemove', (e) => doPan(e, container));
                container.addEventListener('mouseup', () => endPan(container));
                container.addEventListener('mouseleave', () => endPan(container));
            });
            
            // Sync scrolling between containers
            originalContainer.addEventListener('scroll', function() {
                if (!isPanning) {
                    filteredContainer.scrollLeft = originalContainer.scrollLeft;
                    filteredContainer.scrollTop = originalContainer.scrollTop;
                }
            });
            
            filteredContainer.addEventListener('scroll', function() {
                if (!isPanning) {
                    originalContainer.scrollLeft = filteredContainer.scrollLeft;
                    originalContainer.scrollTop = filteredContainer.scrollTop;
                }
            });
            
            // Status-Nachricht anzeigen
            function showStatus(message, type = 'info') {
                statusMessage.textContent = message;
                statusMessage.className = `status-message status-${type}`;
                statusMessage.style.display = 'block';
                
                // Auto-hide nach 5 Sekunden
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
            
            // Screenshot-Funktionalit√§t
            screenshotBtn.addEventListener('click', async function() {
                try {
                    showStatus('Screenshot wird erstellt...', 'info');
                    
                    // Screen Capture API verwenden
                    const stream = await navigator.mediaDevices.getDisplayMedia({
                        video: { mediaSource: 'screen' }
                    });
                    
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    video.onloadedmetadata = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        
                        // Convert to image
                        canvas.toBlob(blob => {
                            const img = new Image();
                            img.onload = function() {
                                originalImage = img;
                                drawOriginalImage();
                                if (autoUpdateCheckbox.checked) {
                                    updatePreview();
                                }
                                showStatus('Screenshot erfolgreich erstellt!', 'success');
                            };
                            img.src = URL.createObjectURL(blob);
                        });
                        
                        // Stop the stream
                        stream.getTracks().forEach(track => track.stop());
                    };
                } catch (error) {
                    console.error('Screenshot error:', error);
                    showStatus('Screenshot fehlgeschlagen. M√∂glicherweise wurde der Zugriff verweigert.', 'error');
                }
            });
            
            // Screen-Sharing f√ºr kontinuierliche Aufnahme
            startScreenShareBtn.addEventListener('click', async function() {
                if (!isScreenSharing) {
                    try {
                        showStatus('Screen-Sharing wird gestartet...', 'info');
                        
                        screenStream = await navigator.mediaDevices.getDisplayMedia({
                            video: { mediaSource: 'screen' }
                        });
                        
                        const video = document.createElement('video');
                        video.srcObject = screenStream;
                        video.play();
                        video.muted = true;
                        
                        // Kontinuierliche Aufnahme alle 2 Sekunden
                        const captureInterval = setInterval(() => {
                            if (!isScreenSharing || !screenStream) {
                                clearInterval(captureInterval);
                                return;
                            }
                            
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(video, 0, 0);
                            
                            canvas.toBlob(blob => {
                                const img = new Image();
                                img.onload = function() {
                                    originalImage = img;
                                    drawOriginalImage();
                                    if (autoUpdateCheckbox.checked) {
                                        updatePreview();
                                    }
                                };
                                img.src = URL.createObjectURL(blob);
                            });
                        }, 2000);
                        
                        isScreenSharing = true;
                        startScreenShareBtn.textContent = '‚èπÔ∏è Screen-Sharing stoppen';
                        recordingIndicator.classList.add('active');
                        showStatus('Screen-Sharing aktiv! Vorschau wird alle 2 Sekunden aktualisiert.', 'success');
                        
                        // Stream-Ende erkennen
                        screenStream.getVideoTracks()[0].addEventListener('ended', () => {
                            stopScreenSharing();
                        });
                        
                    } catch (error) {
                        console.error('Screen sharing error:', error);
                        showStatus('Screen-Sharing fehlgeschlagen. M√∂glicherweise wurde der Zugriff verweigert.', 'error');
                    }
                } else {
                    stopScreenSharing();
                }
            });
            
            function stopScreenSharing() {
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
                isScreenSharing = false;
                startScreenShareBtn.textContent = 'üñ•Ô∏è Screen teilen';
                recordingIndicator.classList.remove('active');
                showStatus('Screen-Sharing beendet.', 'info');
            }
            
            // Auto-Update Toggle
            autoUpdateCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    showStatus('Automatische Vorschau-Aktualisierung aktiviert.', 'success');
                    updatePreview();
                } else {
                    showStatus('Automatische Vorschau-Aktualisierung deaktiviert.', 'info');
                }
            });
            
            // Farb-Control hinzuf√ºgen
            addColorBtn.addEventListener('click', function() {
                addColorControl();
            });
            
            function addColorControl() {
                const colorId = `color-${colorCounter++}`;
                const colorContainer = document.createElement('div');
                colorContainer.className = 'color-container';
                colorContainer.id = `container-${colorId}`;
                
                const colorHeader = document.createElement('div');
                colorHeader.className = 'color-header';
                
                const colorLabel = document.createElement('div');
                colorLabel.innerHTML = `<strong>Farbe ${colorCounter}</strong>`;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'button-icon';
                removeBtn.innerHTML = '√ó';
                removeBtn.title = 'Farbe entfernen';
                removeBtn.onclick = function() {
                    colorsContainer.removeChild(colorContainer);
                    if (colorsContainer.children.length === 0) {
                        addColorControl();
                    }
                    if (autoUpdateCheckbox.checked) {
                        updatePreview();
                    }
                };
                
                colorHeader.appendChild(colorLabel);
                colorHeader.appendChild(removeBtn);
                
                const colorRow = document.createElement('div');
                colorRow.className = 'color-picker';
                
                const colorPickerContainer = document.createElement('div');
                colorPickerContainer.innerHTML = `
                    <label for="${colorId}">Farbe:</label>
                    <div class="color-controls">
                        <input type="color" id="${colorId}" value="#ff0000">
                        <button class="button-icon eyedropper" data-target="${colorId}" title="Pipette - Farbe aus Bild w√§hlen">üîç</button>
                    </div>
                `;
                
                const colorDisplay = document.createElement('div');
                colorDisplay.id = `display-${colorId}`;
                colorDisplay.className = 'color-display';
                colorDisplay.style.backgroundColor = '#ff0000';
                
                colorRow.appendChild(colorPickerContainer);
                colorRow.appendChild(colorDisplay);
                
                const toleranceContainer = document.createElement('div');
                toleranceContainer.className = 'slider-container';
                toleranceContainer.innerHTML = `
                    <label for="tolerance-${colorId}">Farbtoleranz:</label>
                    <input type="range" id="tolerance-${colorId}" min="0" max="100" value="20">
                    <div class="range-display">
                        <span>Gering</span>
                        <span>Hoch</span>
                    </div>
                `;
                
                colorContainer.appendChild(colorHeader);
                colorContainer.appendChild(colorRow);
                colorContainer.appendChild(toleranceContainer);
                
                colorsContainer.appendChild(colorContainer);
                
                // Event-Listener f√ºr Farbauswahl
                const colorInput = document.getElementById(colorId);
                const colorDisplayEl = document.getElementById(`display-${colorId}`);
                const toleranceInput = document.getElementById(`tolerance-${colorId}`);
                
                colorInput.addEventListener('input', function() {
                    colorDisplayEl.style.backgroundColor = colorInput.value;
                    if (autoUpdateCheckbox.checked) {
                        updatePreview();
                    }
                });
                
                toleranceInput.addEventListener('input', function() {
                    if (autoUpdateCheckbox.checked) {
                        updatePreview();
                    }
                });
                
                // Event-Listener f√ºr Pipette
                const eyedropperBtn = colorContainer.querySelector('.eyedropper');
                eyedropperBtn.addEventListener('click', function() {
                    if (!originalImage) {
                        showStatus('Bitte laden Sie zuerst ein Bild hoch oder erstellen Sie einen Screenshot!', 'error');
                        return;
                    }
                    
                    eyedropperActive = true;
                    targetColorPicker = colorId;
                    originalContainer.classList.add('eyedropper-active');
                    filteredContainer.classList.add('eyedropper-active');
                    showStatus('Klicken Sie auf eine Farbe im Original-Bild...', 'info');
                });
            }
            
            // Pipetten-Funktionalit√§t mit Zoom-Support
            originalCanvas.addEventListener('click', function(e) {
                if (!eyedropperActive || !originalImage) return;
                
                const rect = originalCanvas.getBoundingClientRect();
                const containerRect = originalContainer.getBoundingClientRect();
                
                // Berechne die tats√§chlichen Koordinaten unter Ber√ºcksichtigung von Zoom und Scroll
                const canvasX = (e.clientX - containerRect.left + originalContainer.scrollLeft) / zoomLevel;
                const canvasY = (e.clientY - containerRect.top + originalContainer.scrollTop) / zoomLevel;
                
                const ctx = originalCanvas.getContext('2d');
                const pixel = ctx.getImageData(canvasX, canvasY, 1, 1).data;
                
                const hexColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
                
                // Setze die ausgew√§hlte Farbe
                const colorInput = document.getElementById(targetColorPicker);
                const colorDisplay = document.getElementById(`display-${targetColorPicker}`);
                
                colorInput.value = hexColor;
                colorDisplay.style.backgroundColor = hexColor;
                
                // Deaktiviere Pipette
                eyedropperActive = false;
                targetColorPicker = null;
                originalContainer.classList.remove('eyedropper-active');
                filteredContainer.classList.remove('eyedropper-active');
                
                showStatus(`Farbe ${hexColor} ausgew√§hlt!`, 'success');
                
                if (autoUpdateCheckbox.checked) {
                    updatePreview();
                }
            });
            
            // Handle image upload
            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            originalImage = img;
                            drawOriginalImage();
                            if (autoUpdateCheckbox.checked) {
                                updatePreview();
                            }
                            showStatus('Bild erfolgreich hochgeladen!', 'success');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Brightness slider auto-update
            brightnessSlider.addEventListener('input', function() {
                if (autoUpdateCheckbox.checked) {
                    updatePreview();
                }
            });
            
            // Draw original image on canvas
            function drawOriginalImage() {
                if (!originalImage) return;
                
                // Set canvas size to match image
                const maxWidth = 800;
                const scale = Math.min(1, maxWidth / originalImage.width);
                originalCanvas.width = originalImage.width * scale;
                originalCanvas.height = originalImage.height * scale;
                filteredCanvas.width = originalImage.width * scale;
                filteredCanvas.height = originalImage.height * scale;
                
                // Draw original image
                const ctxOriginal = originalCanvas.getContext('2d');
                ctxOriginal.drawImage(originalImage, 0, 0, originalCanvas.width, originalCanvas.height);
                
                // Update zoom display
                updateZoom();
            }
            
            // Update preview when button is clicked
            previewBtn.addEventListener('click', updatePreview);
            
            // Update preview based on current settings
            function updatePreview() {
                if (!originalImage) return;
                
                const ctxOriginal = originalCanvas.getContext('2d');
                const ctxFiltered = filteredCanvas.getContext('2d');
                
                // Get original image data
                const imageData = ctxOriginal.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                const data = imageData.data;
                
                // Sammle alle Farbeinstellungen
                const colors = [];
                document.querySelectorAll('.color-container').forEach(container => {
                    const colorId = container.id.replace('container-color-', 'color-');
                    const colorInput = container.querySelector('input[type="color"]');
                    const toleranceInput = container.querySelector('input[type="range"]');
                    
                    colors.push({
                        color: hexToRgb(colorInput.value),
                        tolerance: toleranceInput.value / 100
                    });
                });
                
                const brightnessTolerance = brightnessSlider.value / 100;
                
                // Filter image
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate brightness (0-1)
                    const brightness = (r + g + b) / (3 * 255);
                    
                    let keepPixel = false;
                    
                    // Pr√ºfe, ob die Pixel-Farbe zu einer der ausgew√§hlten Farben passt
                    for (const colorObj of colors) {
                        const targetColor = colorObj.color;
                        const tolerance = colorObj.tolerance;
                        
                        // Calculate color distance (normalized)
                        const colorDistance = calculateColorDistance(r, g, b, targetColor.r, targetColor.g, targetColor.b);
                        
                        const targetBrightness = (targetColor.r + targetColor.g + targetColor.b) / (3 * 255);
                        const brightnessDiff = Math.abs(brightness - targetBrightness);
                        
                        // Check if pixel color is within tolerance
                        if (colorDistance <= tolerance && brightnessDiff <= brightnessTolerance) {
                            keepPixel = true;
                            break;
                        }
                    }
                    
                    if (!keepPixel) {
                        // Make pixel black
                        data[i] = 0;
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    }
                }
                
                // Draw filtered image
                ctxFiltered.putImageData(imageData, 0, 0);
            }
            
            // Generate and download LUT file
            generateBtn.addEventListener('click', function() {
                if (!originalImage) {
                    showStatus('Bitte laden Sie zuerst ein Bild hoch oder erstellen Sie einen Screenshot!', 'error');
                    return;
                }
                
                showStatus('LUT-Datei wird generiert...', 'info');
                
                // Sammle alle Farbeinstellungen
                const colors = [];
                document.querySelectorAll('.color-container').forEach(container => {
                    const colorId = container.id.replace('container-color-', 'color-');
                    const colorInput = container.querySelector('input[type="color"]');
                    const toleranceInput = container.querySelector('input[type="range"]');
                    
                    colors.push({
                        color: hexToRgb(colorInput.value),
                        tolerance: toleranceInput.value / 100
                    });
                });
                
                const brightnessTolerance = brightnessSlider.value / 100;
                
                // Generate LUT data
                let lutData = 'TITLE "Mehrfarben-Filter LUT"\n';
                lutData += 'LUT_3D_SIZE 33\n';
                lutData += 'DOMAIN_MIN 0.0 0.0 0.0\n';
                lutData += 'DOMAIN_MAX 1.0 1.0 1.0\n\n';
                
                // Generate LUT entries (33x33x33 grid)
                const size = 33;
                for (let b = 0; b < size; b++) {
                    for (let g = 0; g < size; g++) {
                        for (let r = 0; r < size; r++) {
                            const rNorm = r / (size - 1);
                            const gNorm = g / (size - 1);
                            const bNorm = b / (size - 1);
                            
                            // Convert normalized color to RGB (0-255)
                            const rValue = rNorm * 255;
                            const gValue = gNorm * 255;
                            const bValue = bNorm * 255;
                            
                            // Calculate brightness
                            const brightness = (rValue + gValue + bValue) / (3 * 255);
                            
                            let keepColor = false;
                            
                            // Check if color matches any of the target colors
                            for (const colorObj of colors) {
                                const targetColor = colorObj.color;
                                const tolerance = colorObj.tolerance;
                                
                                const colorDistance = calculateColorDistance(
                                    rValue, gValue, bValue, 
                                    targetColor.r, targetColor.g, targetColor.b
                                );
                                
                                const targetBrightness = (targetColor.r + targetColor.g + targetColor.b) / (3 * 255);
                                const brightnessDiff = Math.abs(brightness - targetBrightness);
                                
                                if (colorDistance <= tolerance && brightnessDiff <= brightnessTolerance) {
                                    keepColor = true;
                                    break;
                                }
                            }
                            
                            // Determine output color
                            let outR, outG, outB;
                            
                            if (keepColor) {
                                // Keep the color
                                outR = rNorm;
                                outG = gNorm;
                                outB = bNorm;
                            } else {
                                // Make it black
                                outR = outG = outB = 0;
                            }
                            
                            lutData += `${outR.toFixed(6)} ${outG.toFixed(6)} ${outB.toFixed(6)}\n`;
                        }
                    }
                }
                
                // Create and download file
                const blob = new Blob([lutData], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mehrfarben-filter.cube';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('LUT-Datei erfolgreich heruntergeladen!', 'success');
            });
            
            // Helper function: Convert hex color to RGB
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
            
            // Helper function: Convert RGB to hex
            function rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            // Helper function: Calculate normalized color distance
            function calculateColorDistance(r1, g1, b1, r2, g2, b2) {
                // Simple Euclidean distance in RGB space (normalized to 0-1)
                const rDiff = Math.abs(r1 - r2) / 255;
                const gDiff = Math.abs(g1 - g2) / 255;
                const bDiff = Math.abs(b1 - b2) / 255;
                
                return Math.sqrt(rDiff*rDiff + gDiff*gDiff + bDiff*bDiff) / Math.sqrt(3);
            }
            
            // Cleanup beim Schlie√üen der Seite
            window.addEventListener('beforeunload', function() {
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                }
            });
        });
    </script>
</body>
</html>